import { isAddress } from "viem";
import { z } from "zod";

export const order = z.enum(["ASC", "DESC"]);
export const address = z
  .string()
  .trim()
  .refine((s) => isAddress(s), {
    message: "Invalid address",
  });

export default function getSchema() {
  return {
    publicData: {
      googBlockchainEthereumMainnetUs: {
        accounts: z.object({
          address: z.string().nullable(),
          code_hash: z.string().nullable(),
          code: z.string().nullable(),
          is_contract: z.boolean().nullable(),
        }),
        accountsState: z.object({
          block_hash: z.string(),
          block_number: z.number(),
          block_timestamp: z.date(),
          address: z.string(),
          nonce: z.number(),
          balance: z.bigint(),
          balance_lossless: z.string().nullable(),
          code_hash: z.string(),
          code: z.string().nullable(),
          account_proof: z.array(z.string()),
          storage_hash: z.string(),
        }),
        accountsStateByAddress: z.object({
          block_hash: z.string().nullable(),
          block_number: z.number().nullable(),
          block_timestamp: z.date().nullable(),
          address: z.string().nullable(),
          nonce: z.number().nullable(),
          balance: z.bigint().nullable(),
          balance_lossless: z.string().nullable(),
          code_hash: z.string().nullable(),
          code: z.string().nullable(),
          account_proof: z.array(z.string()),
          storage_hash: z.string().nullable(),
        }),
        blocks: z.object({
          block_hash: z.string(),
          block_number: z.number(),
          block_timestamp: z.date(),
          parent_hash: z.string(),
          size: z.number(),
          extra_data: z.string(),
          gas_limit: z.number(),
          gas_used: z.number(),
          base_fee_per_gas: z.number().nullable(),
          mix_hash: z.string(),
          nonce: z.string(),
          difficulty: z.bigint().nullable(),
          total_difficulty: z.bigint().nullable(),
          miner: z.string(),
          sha3_uncles: z.string(),
          transaction_count: z.number(),
          transactions_root: z.string(),
          receipts_root: z.string(),
          state_root: z.string(),
          logs_bloom: z.string(),
          withdrawals_root: z.string().nullable(),
          withdrawals: z.array(
            z.object({
              index: z.number(),
              validator_index: z.number(),
              address: z.string(),
              amount: z.bigint(),
              amount_lossless: z.string(),
            }),
          ),
        }),
        decodedEvents: z.object({
          block_hash: z.string(),
          block_number: z.number(),
          block_timestamp: z.date(),
          transaction_hash: z.string(),
          transaction_index: z.number(),
          log_index: z.number(),
          address: z.string().nullable(),
          event_hash: z.string().nullable(),
          event_signature: z.string().nullable(),
          topics: z.array(z.string()),
          args: z.unknown().nullable(),
          removed: z.boolean().nullable(),
        }),
        logs: z.object({
          block_hash: z.string(),
          block_number: z.number(),
          block_timestamp: z.date(),
          transaction_hash: z.string(),
          transaction_index: z.number(),
          log_index: z.number(),
          address: z.string().nullable(),
          data: z.string().nullable(),
          topics: z.array(z.string()),
          removed: z.boolean().nullable(),
        }),
        receipts: z.object({
          block_hash: z.string(),
          block_number: z.number(),
          block_timestamp: z.date(),
          transaction_hash: z.string(),
          transaction_index: z.number(),
          from_address: z.string(),
          to_address: z.string().nullable(),
          contract_address: z.string().nullable(),
          cumulative_gas_used: z.number(),
          gas_used: z.number(),
          effective_gas_price: z.number(),
          logs_bloom: z.string(),
          root: z.string().nullable(),
          status: z.number().nullable(),
        }),
        tokenTransfers: z.object({
          block_hash: z.string(),
          block_number: z.number(),
          block_timestamp: z.date(),
          transaction_hash: z.string(),
          transaction_index: z.number(),
          event_index: z.number(),
          batch_index: z.number().nullable(),
          address: z.string().nullable(),
          event_type: z.string(),
          event_hash: z.string(),
          event_signature: z.string(),
          operator_address: z.string().nullable(),
          from_address: z.string(),
          to_address: z.string(),
          token_id: z.string().nullable(),
          quantity: z.string(),
          removed: z.boolean().nullable(),
        }),
        traces: z.object({
          block_hash: z.string(),
          block_number: z.number(),
          block_timestamp: z.date(),
          transaction_hash: z.string(),
          transaction_index: z.number(),
          trace_type: z.string(),
          trace_address: z.array(z.number()),
          subtrace_count: z.number(),
          action: z.array(
            z.object({
              from_address: z.string().nullable(),
              to_address: z.string().nullable(),
              call_type: z.string().nullable(),
              gas: z.number().nullable(),
              input: z.string().nullable(),
              value: z.bigint().nullable(),
              value_lossless: z.string().nullable(),
              init: z.string().nullable(),
              author: z.string().nullable(),
              reward_type: z.string().nullable(),
              refund_address: z.string().nullable(),
              refund_balance: z.bigint().nullable(),
              refund_balance_lossless: z.string().nullable(),
              self_destructed_address: z.string().nullable(),
            }),
          ),
          result: z
            .array(
              z.object({
                gas_used: z.number().nullable(),
                output: z.string().nullable(),
                address: z.string().nullable(),
                code: z.string().nullable(),
              }),
            )
            .nullable(),
          error: z.string().nullable(),
        }),
        transactions: z.object({
          block_hash: z.string(),
          block_number: z.number(),
          block_timestamp: z.date(),
          transaction_hash: z.string(),
          transaction_index: z.number(),
          nonce: z.number(),
          from_address: z.string(),
          to_address: z.string().nullable(),
          value: z.bigint(),
          value_lossless: z.string(),
          gas: z.number(),
          gas_price: z.number().nullable(),
          input: z.string(),
          max_fee_per_gas: z.number().nullable(),
          max_priority_fee_per_gas: z.number().nullable(),
          transaction_type: z.number(),
          chain_id: z.number().nullable(),
          access_list: z.array(z.record(z.unknown())), // Assuming a list of arbitrary objects
          r: z.string().nullable(),
          s: z.string().nullable(),
          v: z.string().nullable(),
          y_parity: z.string().nullable(),
        }),
        transactionsByFromAddress: z.object({
          block_hash: z.string().nullable(),
          block_number: z.number().nullable(),
          block_timestamp: z.date().nullable(),
          transaction_hash: z.string().nullable(),
          transaction_index: z.number().nullable(),
          nonce: z.number().nullable(),
          from_address: z.string().nullable(),
          to_address: z.string().nullable(),
          value: z.bigint().nullable(),
          value_lossless: z.string().nullable(),
          gas: z.number().nullable(),
          gas_price: z.number().nullable(),
          input: z.string().nullable(),
          max_fee_per_gas: z.number().nullable(),
          max_priority_fee_per_gas: z.number().nullable(),
          transaction_type: z.number().nullable(),
          chain_id: z.number().nullable(),
          access_list: z.array(
            z.object({
              address: z.string().nullable(),
              storage_keys: z.array(z.string()),
            }),
          ),
          r: z.string().nullable(),
          s: z.string().nullable(),
          v: z.string().nullable(),
          y_parity: z.string().nullable(),
        }),
        transactionsByToAddress: z.object({
          block_hash: z.string().nullable(),
          block_number: z.number().nullable(),
          block_timestamp: z.date().nullable(),
          transaction_hash: z.string().nullable(),
          transaction_index: z.number().nullable(),
          nonce: z.number().nullable(),
          from_address: z.string().nullable(),
          to_address: z.string().nullable(),
          value: z.bigint().nullable(),
          value_lossless: z.string().nullable(),
          gas: z.number().nullable(),
          gas_price: z.number().nullable(),
          input: z.string().nullable(),
          max_fee_per_gas: z.number().nullable(),
          max_priority_fee_per_gas: z.number().nullable(),
          transaction_type: z.number().nullable(),
          chain_id: z.number().nullable(),
          access_list: z.array(
            z.object({
              address: z.string().nullable(),
              storage_keys: z.array(z.string()),
            }),
          ),
          r: z.string().nullable(),
          s: z.string().nullable(),
          v: z.string().nullable(),
          y_parity: z.string().nullable(),
        }),
      } as const,
    } as const,
  } as const;
}
